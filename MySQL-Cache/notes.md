# Knowing if the cache is enabled

1. Run `mysql> show variables like 'have_query_cache'`

The return has to be:

```
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
```

2. Run `mysql> show variables like 'query_cache'`

The return will be:

```
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| query_alloc_block_size       | 8192    |
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 8388608 |
| query_cache_type             | ON      |
| query_cache_wlock_invalidate | OFF     |
| query_prealloc_size          | 8192    |
+------------------------------+---------+
```
For the cache being enabled is needed:
	- *query_cache_size* > 0
	- *query_cache_type* = ON
	- *query_cache_limit* > 0

# How does the MySQL cache work?

According to [MySQL docs](http://dev.mysql.com/doc/refman/5.7/en/query-cache.html):

> The query cache stores the text of a SELECT statement together with the corresponding result
that was sent to the client. If an identical statement is received later, the server retrieves
the results from the query cache rather than parsing and executing the statement again.
The query cache is shared among sessions, so a result set generated by one client can be
sent in response to the same query issued by another client.

It stores the result of queries with a result bigger than *query_cache_min_res_unit* ([the units are bytes](http://stackoverflow.com/questions/2226997/query-cache-min-res-unit-what-is-it-and-what-does-it-do/2227050#2227050)).

Every time there's a modification of the data invloved in the cached queries, there's a flush of the cache to get the new values.
This makes that caching MySQL is only efficient if the writes are not done too often.

Queries must be *exactly* the same (byte for byte) to be seen as identical (the cache is case sensitive).

The queries are cached according to the *query_cache_type*. Besides, the query cache uses a least recently used (LRU)
strategy to decide which queries to remove from the cache.


# MySQL caching recomendations

For the previous reason, is it not recomended big query cache sizes. Because as bigger the cache size the most the db spends flushing
and locking like is stated on [this blog post](https://www.percona.com/blog/2007/03/23/beware-large-query_cache-sizes/).

Good cache sizes would be *[between 100 and 200 mb](https://haydenjames.io/mysql-query-cache-size-performance/)* top.

Set the cache for ignoring the comments by setting the variable
*query_cache_strip_comments*. [source](https://www.percona.com/doc/percona-server/5.6/performance/query_cache_enhance.html#system-variables)

# Configure MySQL caching variables

The following sentence retrieves all the cache related setting variables:

`show variables like 'query_cache%`

Example result:

```
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| query_alloc_block_size       | 8192    |
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 8388608 |
| query_cache_type             | ON      |
| query_cache_wlock_invalidate | OFF     |
| query_prealloc_size          | 8192    |
+------------------------------+---------+
```

For setting any of these variables:

`SET GLOBAL variable_name = value`


## What's locking?

According to [MySQL manual glosary about locking](http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking):

> The system of protecting a transaction from seeing or changing data that is being queried or changed by other transactions.
The locking strategy must balance reliability and consistency of database operations (the principles of the ACID philosophy)
against the performance needed for good concurrency. Fine-tuning the locking strategy often involves choosing an isolation
level and ensuring all your database operations are safe and reliable for that isolation level.

I fund a further explanation on a [blog post](https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/).

> The answer is in the way the query cache works. Simply stated, the server wants to lock
the query cache both when checking if a result is in the cache and when writing a result
set into the cache. When writing, locking can occur several times: the server sends results
to the cache before computing the entire result set (so the total size of the result set is
not known), so the cache has to assign memory block by block. If a block is full and the
server keeps sending rows, a new block must be assigned, requiring the cache to be locked!

Aditionally on the [MySQL documentation about query-cache-tread-states](https://dev.mysql.com/doc/refman/5.5/en/query-cache-thread-states.html):

> **Waiting for query cache lock**:
> This state occurs while a session is waiting to take the query cache lock. This can happen for any statement that needs to perform some query cache operation, such as an INSERT or DELETE that invalidates the query cache, a SELECT that looks for a cached entry, RESET QUERY CACHE, and so forth.

## Query cache SELECT Options

* **SQL_CACHE** : The query will be cached
* **SQL_NO_CACHE**: The query will not be cached

Usage:
```
SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;
```
[source](http://dev.mysql.com/doc/refman/5.7/en/query-cache-in-select.html)

## query_cache_type
* *0* or *OFF* → prevents caching
* *1* → enables chaching except of those statements that begin with `SELECT SQL_NO_CACHE`
* *2* → enables caching only for the queries with `SELECT SQL_CACHE`

# Mesuring optimization

For getting info about usage of cache we can execute:

```sql
SHOW STATUS LIKE 'Qcache'
```

The result will be as follows:

```
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Qcache_free_blocks      | 65     |
| Qcache_free_memory      | 201440 |
| Qcache_hits             | 18868  |
| Qcache_inserts          | 2940   |
| Qcache_lowmem_prunes    | 665    |
| Qcache_not_cached       | 246    |
| Qcache_queries_in_cache | 492    |
| Qcache_total_blocks     | 1430   |
+-------------------------+--------+
8 rows in set (0.00 sec)
```

* The [Qcache_hits](http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_hits)
mesures the number of times the db is retrieving information from cache.
* The [Qcache_inserts](http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_inserts) is
the number of queries added to the query cache.
* The [Qcache_not_cached](http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_not_cached)
is the number of noncached queries (not cacheable, or not cached due to the
the query_cache_type).
* The [Qcache_lowmem_prunes](http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_lowmem_prunes)
is the number of queries that have been removed in order to allocate new ones in
the cache.

> [Read this](http://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_free_blocks)
for more information about this variables

## Some formulas to mesure eficiency

**Query cache hit rate**: `((Qcahe_hits / (Qcache_hits + Qcache_inserts + Qcache_not_cached))*100)`

Query cache hit rate is the percentage of queries served by cache instead of
being re-executed by the database repeatedly.

> Should be as close to 100% as possible. If the hit rate is below 50%, is better
to keep the Qcache disabled. [source](https://haydenjames.io/mysql-query-cache-size-performance/)

**Current cache size compared with maximum available size**: `((query_cache_size-Qcache_free_memory)/query_cache_size)*100`

**Prune ratio**: `Qcache_inserts/Qcache_prunes`

> We need to observe the Qcache_lowmem_prunes  status variable and try to
increase/adjust the size of the cache till we get a very low value ratio for the
variable [source](https://www.percona.com/blog/2015/01/02/the-mysql-query-cache-how-it-works-and-workload-impacts-both-good-and-bad/).

> For more eficiency related formulas check [the following stackoverflow post](http://dba.stackexchange.com/a/7345)

# Interesting resources

* [Speed Up Your Web Site With MySQL Query Caching](http://www.howtogeek.com/howto/programming/speed-up-your-web-site-with-mysql-query-caching/)
* [Avoid This When Tuning MySQL Query Cache for Performance](https://haydenjames.io/mysql-query-cache-size-performance/)
* [How query cache can cause performance problems?](https://web.archive.org/web/20160129162137/http://www.psce.com/blog/kb/how-query-cache-can-cause-performance-problems/)
* [MySQL Dev Manual: The MySQL Query Cache](http://dev.mysql.com/doc/refman/5.7/en/query-cache.html)
* [The MySQL query cache: Worst enemy or best friend?](https://www.percona.com/blog/2015/08/07/mysql-query-cache-worst-enemy-best-friend/)